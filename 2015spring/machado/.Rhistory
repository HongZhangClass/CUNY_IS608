library(grid)
library(gridExtra)
# This Function will create the URL in the right format to fetch data from Yahoo Finance. The URL will be
# dynamically created using the asset symbol passed to the function.
createURL <- function(asset){
return(paste("http://real-chart.finance.yahoo.com/table.csv?s=", asset, "&a=10&b=01&c=2009&d=10&e=01&f=2014&g=m&ignore=.csv", sep=''))
}
webData=TRUE # Get data from the web if TRUE, otherwise get data from the local file system.
# The function below will convert the Date from String to Date type.
getAndTidyData <- function(asset){
if(webData){
df <- read.csv(createURL(asset), header=TRUE, stringsAsFactors=FALSE)
}else{
df <- read.csv(paste('c:/Temp/SAP_500.csv', asset, '.csv', sep=''), header=TRUE, stringsAsFactors=FALSE)
}
# We will convert the date column from a String to a Date
df$Date <- as.Date(df$Date, "%Y-%m-%d")
# Check for outliers
#df <- filterOutLiers(df)
return(df)
}
#Function to monthly return of an asset (For a 5 year period).
calculateReturns <- function(asset){
returns = c()
df <- getAndTidyData(asset)
for(i in 1:length(df$Adj.Close)){
ret = (df$Adj.Close[i] - df$Adj.Close[i+1])/df$Adj.Close[i+1]
returns <- append(returns, ret)
}
returns <- returns[!is.na(returns)]
return(returns)
}
calculateReturnsMean <- function(price){
returns = c()
for(i in 1:length(price)){
ret = (price[i] - price[i+1])/price[i+1]
returns <- append(returns, ret)
}
returns <- returns[!is.na(returns)]
return(mean(returns))
}
# The function below uses the Lattice graphics package for plotting the densities.
generateDensityPlot <- function(asset, assetReturns){
d<-densityplot(~assetReturns, main=paste("Density Plot for returns of ", asset), xlab=paste("Asset = ", asset))
return(d)
}
df_election_years <- read.csv('c:/Temp/election_years.csv', stringsAsFactors=FALSE, header=TRUE)
election_years <- sort(df_election_years$Year)
df <- read.csv('c:/Temp/ttt.csv', stringsAsFactors=FALSE, header=TRUE)
df <- cbind(df, Year=as.numeric(substr(df$Date, 1, 4)))
df <- cbind(df, Month=as.numeric(substr(df$Date, 6, 7)))
df <- cbind(df, Day=as.numeric(substr(df$Date, 9, 10)))
df<-df[df$Year>=1952 & df$Year<=2011,]
#df<-df[!(df$Year==1952 & df$Month<5),]
write.csv(file='c:/Temp/df.csv', x=df, row.names=FALSE, na="")
binCount <- 1
years <- sort(unique(df$Year))
bins <- c()
for(year in years){
bins<-append(bins, rep(binCount,length(df[df$Year==year&df$Month>=1&df$Month<=04,]$Day)))
binCount = binCount + 1
bins<-append(bins, rep(binCount,length(df[df$Year==year&df$Month>=05&df$Month<=10,]$Day)))
binCount = binCount + 1
bins<-append(bins, rep(binCount,length(df[df$Year==year&df$Month>=11&df$Month<=12,]$Day)))
}
bins <- sort(bins, decreasing = TRUE)
df <- cbind(df,bins)
write.csv(file='c:/Temp/bins.csv', x=df, row.names=FALSE, na="")
# returns <- ddply(df, .(Year), function(x) c(YearlyReturns=calculateReturnsMean(x$Close)))
# returns <- abs(returns)
# write.csv(file='c:/Temp/returns.csv', x=returns, row.names=FALSE, na="")
# ggplot(returns, aes(x = Year, y = YearlyReturns)) + geom_bar(stat = "identity") + coord_flip()
#
# for(year in election_years){
#   print(year)
# }
library(ggplot2)
library(plyr)
library(lattice)
library(grid)
library(gridExtra)
# This Function will create the URL in the right format to fetch data from Yahoo Finance. The URL will be
# dynamically created using the asset symbol passed to the function.
createURL <- function(asset){
return(paste("http://real-chart.finance.yahoo.com/table.csv?s=", asset, "&a=10&b=01&c=2009&d=10&e=01&f=2014&g=m&ignore=.csv", sep=''))
}
webData=TRUE # Get data from the web if TRUE, otherwise get data from the local file system.
# The function below will convert the Date from String to Date type.
getAndTidyData <- function(asset){
if(webData){
df <- read.csv(createURL(asset), header=TRUE, stringsAsFactors=FALSE)
}else{
df <- read.csv(paste('c:/Temp/SAP_500.csv', asset, '.csv', sep=''), header=TRUE, stringsAsFactors=FALSE)
}
# We will convert the date column from a String to a Date
df$Date <- as.Date(df$Date, "%Y-%m-%d")
# Check for outliers
#df <- filterOutLiers(df)
return(df)
}
#Function to monthly return of an asset (For a 5 year period).
calculateReturns <- function(asset){
returns = c()
df <- getAndTidyData(asset)
for(i in 1:length(df$Adj.Close)){
ret = (df$Adj.Close[i] - df$Adj.Close[i+1])/df$Adj.Close[i+1]
returns <- append(returns, ret)
}
returns <- returns[!is.na(returns)]
return(returns)
}
calculateReturnsMean <- function(price){
returns = c()
for(i in 1:length(price)){
ret = (price[i] - price[i+1])/price[i+1]
returns <- append(returns, ret)
}
returns <- returns[!is.na(returns)]
return(mean(returns))
}
# The function below uses the Lattice graphics package for plotting the densities.
generateDensityPlot <- function(asset, assetReturns){
d<-densityplot(~assetReturns, main=paste("Density Plot for returns of ", asset), xlab=paste("Asset = ", asset))
return(d)
}
df_election_years <- read.csv('c:/Temp/election_years.csv', stringsAsFactors=FALSE, header=TRUE)
election_years <- sort(df_election_years$Year)
df <- read.csv('c:/Temp/ttt.csv', stringsAsFactors=FALSE, header=TRUE)
df <- cbind(df, Year=as.numeric(substr(df$Date, 1, 4)))
df <- cbind(df, Month=as.numeric(substr(df$Date, 6, 7)))
df <- cbind(df, Day=as.numeric(substr(df$Date, 9, 10)))
df<-df[df$Year>=1952 & df$Year<=2011,]
#df<-df[!(df$Year==1952 & df$Month<5),]
write.csv(file='c:/Temp/df.csv', x=df, row.names=FALSE, na="")
binCount <- 1
years <- sort(unique(df$Year))
bins <- c()
for(year in years){
bins<-append(bins, rep(binCount,length(df[df$Year==year&df$Month>=1&df$Month<=04,]$Day)))
binCount = binCount + 1
bins<-append(bins, rep(binCount,length(df[df$Year==year&df$Month>=05&df$Month<=10,]$Day)))
binCount = binCount + 1
bins<-append(bins, rep(binCount,length(df[df$Year==year&df$Month>=11&df$Month<=12,]$Day)))
}
bins <- sort(bins, decreasing = TRUE)
df <- cbind(df,bins)
write.csv(file='c:/Temp/bins.csv', x=df, row.names=FALSE, na="")
returns <- ddply(df, .(bins), function(x) c(YearlyReturns=calculateReturnsMean(x$Close)))
ggplot(returns, aes(x = bins, y = YearlyReturns)) + geom_bar(stat = "identity")
# returns <- ddply(df, .(Year), function(x) c(YearlyReturns=calculateReturnsMean(x$Close)))
# returns <- abs(returns)
# write.csv(file='c:/Temp/returns.csv', x=returns, row.names=FALSE, na="")
# ggplot(returns, aes(x = Year, y = YearlyReturns)) + geom_bar(stat = "identity") + coord_flip()
#
# for(year in election_years){
#   print(year)
# }
head(df)
head(returns)
gg <- ddply(bins, .(Year, bins))
gg <- ddply(bins, .(Year, bins), function(x) c(mean(bins)))
gg <- ddply(bins, .(Year, bins), function(x) c(mean(x$bins)))
gg <- ddply(df, .(Year, bins), function(x) c(mean(x$bins)))
gg
library(ggplot2)
library(plyr)
library(lattice)
library(grid)
library(gridExtra)
# This Function will create the URL in the right format to fetch data from Yahoo Finance. The URL will be
# dynamically created using the asset symbol passed to the function.
createURL <- function(asset){
return(paste("http://real-chart.finance.yahoo.com/table.csv?s=", asset, "&a=10&b=01&c=2009&d=10&e=01&f=2014&g=m&ignore=.csv", sep=''))
}
webData=TRUE # Get data from the web if TRUE, otherwise get data from the local file system.
# The function below will convert the Date from String to Date type.
getAndTidyData <- function(asset){
if(webData){
df <- read.csv(createURL(asset), header=TRUE, stringsAsFactors=FALSE)
}else{
df <- read.csv(paste('c:/Temp/SAP_500.csv', asset, '.csv', sep=''), header=TRUE, stringsAsFactors=FALSE)
}
# We will convert the date column from a String to a Date
df$Date <- as.Date(df$Date, "%Y-%m-%d")
# Check for outliers
#df <- filterOutLiers(df)
return(df)
}
#Function to monthly return of an asset (For a 5 year period).
calculateReturns <- function(asset){
returns = c()
df <- getAndTidyData(asset)
for(i in 1:length(df$Adj.Close)){
ret = (df$Adj.Close[i] - df$Adj.Close[i+1])/df$Adj.Close[i+1]
returns <- append(returns, ret)
}
returns <- returns[!is.na(returns)]
return(returns)
}
calculateReturnsMean <- function(price){
returns = c()
for(i in 1:length(price)){
ret = (price[i] - price[i+1])/price[i+1]
returns <- append(returns, ret)
}
returns <- returns[!is.na(returns)]
return(mean(returns))
}
# The function below uses the Lattice graphics package for plotting the densities.
generateDensityPlot <- function(asset, assetReturns){
d<-densityplot(~assetReturns, main=paste("Density Plot for returns of ", asset), xlab=paste("Asset = ", asset))
return(d)
}
df_election_years <- read.csv('c:/Temp/election_years.csv', stringsAsFactors=FALSE, header=TRUE)
election_years <- sort(df_election_years$Year)
df <- read.csv('c:/Temp/ttt.csv', stringsAsFactors=FALSE, header=TRUE)
df <- cbind(df, Year=as.numeric(substr(df$Date, 1, 4)))
df <- cbind(df, Month=as.numeric(substr(df$Date, 6, 7)))
df <- cbind(df, Day=as.numeric(substr(df$Date, 9, 10)))
df<-df[df$Year>=1952 & df$Year<=2011,]
#df<-df[!(df$Year==1952 & df$Month<5),]
write.csv(file='c:/Temp/df.csv', x=df, row.names=FALSE, na="")
binCount <- 1
years <- sort(unique(df$Year))
bins <- c()
for(year in years){
bins<-append(bins, rep(binCount,length(df[df$Year==year&df$Month>=1&df$Month<=04,]$Day)))
binCount = binCount + 1
bins<-append(bins, rep(binCount,length(df[df$Year==year&df$Month>=05&df$Month<=10,]$Day)))
binCount = binCount + 1
bins<-append(bins, rep(binCount,length(df[df$Year==year&df$Month>=11&df$Month<=12,]$Day)))
}
bins <- sort(bins, decreasing = TRUE)
df <- cbind(df,bins)
write.csv(file='c:/Temp/bins.csv', x=df, row.names=FALSE, na="")
returns <- ddply(df, .(bins), function(x) c(YearlyReturns=calculateReturnsMean(x$Close)))
write.csv(file='c:/Temp/returns.csv', x=returns, row.names=FALSE, na="")
ggplot(returns, aes(x = bins, y = YearlyReturns)) + geom_bar(stat = "identity")
# returns <- ddply(df, .(Year), function(x) c(YearlyReturns=calculateReturnsMean(x$Close)))
# returns <- abs(returns)
# write.csv(file='c:/Temp/returns.csv', x=returns, row.names=FALSE, na="")
# ggplot(returns, aes(x = Year, y = YearlyReturns)) + geom_bar(stat = "identity") + coord_flip()
#
# for(year in election_years){
#   print(year)
# }
shiny::runApp('C:/0001_Project_608/project')
shiny::runApp('C:/0001_Project_608/project')
shiny::runApp('C:/0001_Project_608/project')
shiny::runApp('C:/0001_Project_608/project')
shiny::runApp('C:/0001_Project_608/project')
shiny::runApp('C:/0001_Project_608/project')
shiny::runApp('C:/0001_Project_608/project')
shiny::runApp('C:/0001_Project_608/project')
shiny::runApp('C:/0001_Project_608/project')
countNonZeroPivots <- function(inputMatrix){
numRows <- nrow(inputMatrix)
noOfPivots = 0
for( i in 1:(numRows)){
if(inputMatrix[i,i] != 0){
noOfPivots = noOfPivots + 1
}
}
return(noOfPivots)
}
# The function below returns the traspose of a m x n matrix. This is a generic function.
mytranspose <- function(inputMatrix){
A <- inputMatrix
numRows <- nrow(A)
numCols <- ncol(A)
transposeVector <- c()
for( i in 1:(numCols)){
transposeVector <- append(transposeVector, A[,i])
}
transposeMatrix <- matrix(transposeVector, nrow=numCols, ncol=numRows, byrow=TRUE)
return(transposeMatrix)
}
A <- matrix(c(1,1,3,5,2,-1,5,-9,-2,1,-2,4),nrow=3, ncol=4,byrow=TRUE)
nonzero_pivots_in_A = countNonZeroPivots(A)
# Print the Rank of A.
print(paste("Answer: The Rank of Matrix A is : ", nonzero_pivots_in_A))
tramspose_A <- mytranspose(A)
print(tramspose_A)
#print(paste("Answer: The Transpose of Matrix A is : ", tramspose_A))
print(A)
library(polynom)
countNonZeroPivots <- function(inputMatrix){
numRows <- nrow(inputMatrix)
noOfPivots = 0
for( i in 1:(numRows)){
if(inputMatrix[i,i] != 0){
noOfPivots = noOfPivots + 1
}
}
return(noOfPivots)
}
# The function below returns the traspose of a m x n matrix. This is a generic function.
mytranspose <- function(inputMatrix){
A <- inputMatrix
numRows <- nrow(A)
numCols <- ncol(A)
transposeVector <- c()
for( i in 1:(numCols)){
transposeVector <- append(transposeVector, A[,i])
}
transposeMatrix <- matrix(transposeVector, nrow=numCols, ncol=numRows, byrow=TRUE)
return(transposeMatrix)
}
A <- matrix(c(1,1,3,5,2,-1,5,-9,-2,1,-2,4),nrow=3, ncol=4,byrow=TRUE)
nonzero_pivots_in_A = countNonZeroPivots(A)
# Print the Rank of A.
print(paste("Answer: The Rank of Matrix A is : ", nonzero_pivots_in_A))
tramspose_A <- mytranspose(A)
print(tramspose_A)
#print(paste("Answer: The Transpose of Matrix A is : ", tramspose_A))
shiny::runApp('C:/001-Semester_02_CUNY/608_knowledge_And_Visual_Analytics/Week_05_06/Solution_2')
shiny::runApp('C:/0001_Project_608/project')
shiny::runApp('C:/0001_Project_608/project')
install.packages("lbfgs")
install.packages("lbfgs")
shiny::runApp('C:/0001_Project_608/project')
shiny::runApp('C:/0001_Project_608/project')
shiny::runApp('C:/0001_Project_608/project')
shiny::runApp('C:/0001_Project_608/project')
shiny::runApp('C:/0001_Project_608/project')
shiny::runApp('C:/0001_Project_608/project')
shiny::runApp('C:/0001_Project_608/project')
shiny::runApp('C:/001-Semester_02_CUNY/608_knowledge_And_Visual_Analytics/Week_05_06/Solution_2')
shiny::runApp('C:/001-Semester_02_CUNY/608_knowledge_And_Visual_Analytics/Week_05_06/Solution_2')
shiny::runApp('C:/001-Semester_02_CUNY/608_knowledge_And_Visual_Analytics/Week_05_06/Solution_2')
shiny::runApp('C:/0001_Project_608/project')
shiny::runApp('C:/0001_Project_608/project')
library(ggplot2)
library(plyr)
library(lattice)
library(scales)
library(grid)
library(gridExtra)
options(warn=0)
# This Function will create the URL in the right format to fetch data from Yahoo Finance. The URL will be
# dynamically created using the asset symbol passed to the function.
createURL <- function(asset){
return(paste("http://real-chart.finance.yahoo.com/table.csv?s=", asset, "&a=10&b=01&c=2009&d=10&e=01&f=2014&g=m&ignore=.csv", sep=''))
}
webData=TRUE # Get data from the web if TRUE, otherwise get data from the local file system.
# The function below will convert the Date from String to Date type.
getAndTidyData <- function(asset){
if(webData){
df <- read.csv(createURL(asset), header=TRUE, stringsAsFactors=FALSE)
}else{
df <- read.csv(paste('c:/Temp/SAP_500.csv', asset, '.csv', sep=''), header=TRUE, stringsAsFactors=FALSE)
}
# We will convert the date column from a String to a Date
df$Date <- as.Date(df$Date, "%Y-%m-%d")
# Check for outliers
#df <- filterOutLiers(df)
return(df)
}
#Function to monthly return of an asset (For a 5 year period).
calculateReturns <- function(asset){
returns = c()
df <- getAndTidyData(asset)
for(i in 1:length(df$Adj.Close)){
ret = (df$Adj.Close[i] - df$Adj.Close[i+1])/df$Adj.Close[i+1]
returns <- append(returns, ret)
}
returns <- returns[!is.na(returns)]
return(returns)
}
calculateReturnsMean <- function(price){
returns = c()
for(i in 1:length(price)){
ret = (price[i] - price[i+1])/price[i+1]
returns <- append(returns, ret)
}
returns <- returns[!is.na(returns)]
return(mean(returns))
}
# The function below uses the Lattice graphics package for plotting the densities.
generateDensityPlot <- function(asset, assetReturns){
d<-densityplot(~assetReturns, main=paste("Density Plot for returns of ", asset), xlab=paste("Asset = ", asset))
return(d)
}
df_election_years <- read.csv('c:/Temp/election_years.csv', stringsAsFactors=FALSE, header=TRUE)
election_years <- sort(df_election_years$Year)
df <- read.csv('c:/Temp/ttt.csv', stringsAsFactors=FALSE, header=TRUE)
df <- cbind(df, Year=as.numeric(substr(df$Date, 1, 4)))
df <- cbind(df, Month=as.numeric(substr(df$Date, 6, 7)))
df <- cbind(df, Day=as.numeric(substr(df$Date, 9, 10)))
df<-df[df$Year>=1953 & df$Year<=2011,]
df<-df[!(df$Year==1953 & df$Month<10) & !(df$Year==2012 & df$Month<9),]
write.csv(file='c:/Temp/df.csv', x=df, row.names=FALSE, na="")
binCount <- 1953
years <- sort(unique(df$Year))
period <- c()
for(year in years){
print(paste("Processing year : ", year))
period<-append(period, rep(binCount,length(df[df$Year==year&df$Month>=10,]$Day)))
if(year != max(years)){
period<-append(period, rep(binCount,length(df[df$Year==(year+1)&df$Month<10,]$Day)))
}
binCount = binCount + 1
}
period <- sort(period, decreasing = TRUE)
write.csv(file='c:/Temp/Raw_period.csv', x=period, row.names=FALSE, na="")
df <- cbind(df,period)
write.csv(file='c:/Temp/period.csv', x=df, row.names=FALSE, na="")
write.csv(file='c:/Temp/years.csv', x=years, row.names=FALSE, na="")
returns <- ddply(df, .(period), function(x) c(YearlyReturns=calculateReturnsMean(x$Close)*100))
election_color <- c()
for(year in years){
if(year%in%election_years){
election_color <- append(election_color, 'firebrick1')
}else{
election_color <- append(election_color, 'skyblue1')
}
}
returns <- ddply(returns, .(period), function(x) c(YearlyReturns=x$YearlyReturns,
Sign=sign(x$YearlyReturns), IsElectionYear=(x$period%in%election_years)))
returns <- cbind(returns, election_color, stringsAsFactors=FALSE)
write.csv(file='./data/returns.csv', x=returns, row.names=FALSE, na="")
ggplot(returns, aes(x = period, y = YearlyReturns)) +
geom_bar(stat = "identity", colour="white", fill=returns$election_color)+
xlab("Time period") +
ylab("% Returns") +
geom_text( aes( label = period), vjust = .5, colour ='black',angle=90, position = position_dodge(5), size = 4)
vv
shiny::runApp('C:/0001_Project_608/project')
vv
vv
shiny::runApp('C:/0001_Project_608/project')
# This script determines what the server does.
#
library(shiny)
library(plyr)
library(ggplot2)
options(warn=-1)
calculateReturnsMean <- function(price){
returns = c()
for(i in 1:length(price)){
ret = (price[i] - price[i+1])/price[i+1]
returns <- append(returns, ret)
}
returns <- returns[!is.na(returns)]
return(mean(returns))
}
setwd('C:/0001_Project_608/project')
df_election_years <- read.csv('./data/election_years.csv', stringsAsFactors=FALSE, header=TRUE)
election_years <- sort(df_election_years$Year)
df <- read.csv('./data/SAP_500.csv', stringsAsFactors=FALSE, header=TRUE)
df <- cbind(df, Year=as.numeric(substr(df$Date, 1, 4)))
df <- cbind(df, Month=as.numeric(substr(df$Date, 6, 7)))
df <- cbind(df, Day=as.numeric(substr(df$Date, 9, 10)))
df<-df[df$Year>=1953 & df$Year<=2011,]
df<-df[!(df$Year==1953 & df$Month<10) & !(df$Year==2012 & df$Month<9),]
binCount <- 1953
years <- sort(unique(df$Year))
period <- c()
for(year in years){
print(paste("Processing year : ", year))
period<-append(period, rep(binCount,length(df[df$Year==year&df$Month>=10,]$Day)))
if(year != max(years)){
period<-append(period, rep(binCount,length(df[df$Year==(year+1)&df$Month<10,]$Day)))
}
binCount = binCount + 1
}
period <- sort(period, decreasing = TRUE)
# write.csv(file='c:/Temp/Raw_period.csv', x=period, row.names=FALSE, na="")
df <- cbind(df,period)
#     write.csv(file='c:/Temp/period.csv', x=df, row.names=FALSE, na="")
#     write.csv(file='c:/Temp/years.csv', x=years, row.names=FALSE, na="")
returns <- ddply(df, .(period), function(x) c(YearlyReturns=calculateReturnsMean(x$Close)*100))
election_color <- c()
for(year in years){
if(year%in%election_years){
election_color <- append(election_color, 'firebrick1')
}else{
election_color <- append(election_color, 'skyblue1')
}
}
returns <- ddply(returns, .(period), function(x) c(YearlyReturns=x$YearlyReturns,
Sign=sign(x$YearlyReturns), IsElectionYear=(x$period%in%election_years)))
returns <- cbind(returns, election_color, stringsAsFactors=FALSE)
write.table(file='./www/returns.csv', x=subset(returns, select=c("period", "YearlyReturns")), col.names=FALSE, row.names=FALSE, na="")
ggplot(returns, aes(x = period, y = YearlyReturns, ymax=max(YearlyReturns)*1.05)) +
geom_bar(stat = "identity", colour="white", fill=returns$election_color)+
xlab("Time period") +
ylab("% Returns") +
geom_text( aes( label = period), vjust = .5, colour ='black',angle=90, position = position_dodge(5), size = 4)
head(returns)
head(df)
df$Close
df$Close[1]
df$Year[1]
df$Day[1]
df$Month[1]
years
for(year in years){print(year)}
df$period
returns
head(returns)
head(df)
head(returns)
period
shiny::runApp()
shiny::runApp()
shiny::runApp()
shiny::runApp()
shiny::runApp()
shiny::runApp()
shiny::runApp()
shiny::runApp()
